<!DOCTYPE html>
<html>
<head>
  <title>Terminal</title>
  <link rel="stylesheet" href="/static/lib/xterm.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cascadia+Code&family=Fira+Code&family=JetBrains+Mono&family=Source+Code+Pro&display=swap" rel="stylesheet">
  <style>
    body { margin: 0; font-family: monospace; transition: background 0.3s, color 0.3s; }
    #status { position: absolute; top: 10px; left: 10px; z-index: 1000; }

    /* Pane container */
    #pane-container { display: flex; flex-direction: row; height: 100vh; width: 100vw; }
    .pane { flex: 1; position: relative; overflow: hidden; min-width: 0; }
    .pane.active { box-shadow: inset 0 0 0 2px rgba(100,150,255,0.35); }

    /* Divider */
    #pane-divider {
      flex: 0 0 4px; cursor: col-resize;
      background: rgba(128,128,128,0.15);
      transition: background 0.15s;
      z-index: 1;
    }
    #pane-divider:hover, #pane-divider.dragging {
      background: rgba(100,150,255,0.5);
    }

    /* Toolbar — translucent right-edge drawer */
    #toolbar-tab {
      position: fixed; bottom: 12px; right: 0; z-index: 1001;
      cursor: pointer; padding: 10px 4px;
      background: rgba(255,255,255,0.06);
      border-radius: 8px 0 0 8px;
      border: 1px solid rgba(255,255,255,0.08); border-right: none;
      backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px);
      color: inherit; font-size: 12px; line-height: 1;
      display: flex; align-items: center; justify-content: center;
      transition: background 0.2s, right 0.25s ease, box-shadow 0.2s;
      user-select: none;
    }
    #toolbar-tab:hover {
      background: rgba(255,255,255,0.12);
      box-shadow: 0 0 12px rgba(100,150,255,0.15);
    }
    #toolbar-tab .arrow {
      font-size: 9px; transition: transform 0.3s ease; display: block;
    }
    #toolbar-wrapper { position: fixed; bottom: 0; right: 0; z-index: 1000; pointer-events: none; }
    #toolbar {
      pointer-events: auto;
      display: flex; flex-direction: column; gap: 12px;
      padding: 16px 12px; min-width: 170px;
      background: rgba(255,255,255,0.04);
      border-left: 1px solid rgba(255,255,255,0.08);
      border-top: 1px solid rgba(255,255,255,0.08);
      border-top-left-radius: 14px;
      backdrop-filter: blur(24px) saturate(1.2);
      -webkit-backdrop-filter: blur(24px) saturate(1.2);
      box-shadow: -4px -2px 24px rgba(0,0,0,0.2), 0 0 0 1px rgba(255,255,255,0.03) inset;
      max-height: 80vh; box-sizing: border-box; overflow-y: auto;
      transform: translateX(100%); transition: transform 0.25s ease;
    }
    #toolbar-wrapper.open #toolbar { transform: translateX(0); }
    #toolbar .group-label {
      font-size: 9px; text-transform: uppercase; letter-spacing: 1.5px;
      opacity: 0.35; padding: 0 2px; margin-top: 2px; font-weight: 600;
    }
    #toolbar select, #toolbar button {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.08); border-radius: 6px;
      padding: 6px 10px; cursor: pointer; font-size: 12px; line-height: 1.4;
      color: inherit; transition: all 0.15s; width: 100%;
      text-align: left; box-sizing: border-box;
    }
    #toolbar select:hover, #toolbar button:hover {
      background: rgba(255,255,255,0.1);
      border-color: rgba(255,255,255,0.18);
    }
    #toolbar select { font-family: inherit; }
    #toolbar .tool-row {
      display: flex; align-items: center; gap: 6px;
    }
    #toolbar .tool-row button {
      width: auto; flex: 1; text-align: center; padding: 8px; font-size: 18px;
      border-radius: 8px; display: flex; align-items: center; justify-content: center;
    }
    #toolbar .tool-row button:hover {
      background: rgba(100,150,255,0.12);
      border-color: rgba(100,150,255,0.25);
      box-shadow: 0 0 8px rgba(100,150,255,0.1);
    }
    #toolbar .font-size-row {
      display: flex; align-items: center; gap: 4px;
    }
    #toolbar .font-size-row button {
      width: auto; flex-shrink: 0; padding: 5px 10px; text-align: center;
      font-size: 12px; font-weight: 600;
    }
    #toolbar .font-size-row span { flex: 1; text-align: center; font-size: 12px; opacity: 0.7; }
    #toolbar .separator {
      height: 1px; width: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.08), transparent);
    }

    /* Speak button inside toolbar */
    #speak-btn { display: none; }
    #speak-btn.supported { display: flex; }
    #speak-btn.recording {
      background: rgba(255,50,50,0.12) !important;
      border-color: rgba(255,80,80,0.4) !important;
      box-shadow: 0 0 12px rgba(255,50,50,0.15);
    }
    #speak-btn.recording .speak-dot {
      width: 8px; height: 8px; border-radius: 50%; background: #ff4444;
      animation: pulse 1s infinite; flex-shrink: 0;
    }

    /* Search bar */
    #search-bar {
      display: none; position: fixed; top: 10px; right: 40px; z-index: 1001;
      padding: 6px 8px; border-radius: 6px;
      border: 1px solid rgba(128,128,128,0.4);
      backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
      gap: 4px; align-items: center;
    }
    #search-bar.visible { display: flex; }
    #search-bar input {
      background: transparent; border: 1px solid rgba(128,128,128,0.3); border-radius: 3px;
      padding: 3px 6px; font-size: 13px; color: inherit; outline: none; width: 200px;
      font-family: inherit;
    }
    #search-bar input:focus { border-color: rgba(100,150,255,0.6); }
    #search-bar button {
      background: none; border: 1px solid rgba(128,128,128,0.3); border-radius: 3px;
      padding: 2px 8px; cursor: pointer; color: inherit; font-size: 12px;
    }
    #search-bar button:hover { border-color: rgba(128,128,128,0.7); }

    /* Voice dictation */
    @keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.5; } }
    #dictation-preview {
      display: none; position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
      z-index: 1001; width: min(85vw, 700px); border-radius: 16px;
      border: 1px solid rgba(128,128,128,0.25);
      backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
      box-shadow: 0 8px 32px rgba(0,0,0,0.3), 0 0 0 1px rgba(255,255,255,0.05) inset;
      flex-direction: column; overflow: hidden;
    }
    #dictation-preview.visible { display: flex; }
    #dictation-header {
      display: flex; align-items: center; gap: 8px;
      padding: 12px 16px; border-bottom: 1px solid rgba(128,128,128,0.15);
      font-size: 13px; font-weight: 600; letter-spacing: 0.3px;
    }
    #dictation-header .rec-dot {
      width: 8px; height: 8px; border-radius: 50%; background: #ff4444;
      animation: pulse 1s infinite; flex-shrink: 0;
    }
    #dictation-header .shortcut {
      margin-left: auto; font-size: 11px; opacity: 0.5; font-weight: 400;
    }
    #dictation-input {
      width: 100%; min-height: 80px; max-height: 200px; resize: vertical;
      background: transparent; border: none; padding: 14px 16px;
      font-size: 16px; line-height: 1.5; color: inherit;
      outline: none; font-family: inherit; word-wrap: break-word;
      box-sizing: border-box;
    }
    #dictation-input::placeholder { opacity: 0.4; }
    #dictation-interim {
      padding: 0 16px 8px; font-size: 14px; line-height: 1.4;
      font-style: italic; opacity: 0.45; min-height: 0;
      word-wrap: break-word; display: none;
    }
    #dictation-interim.has-text { display: block; }
    #dictation-actions {
      display: flex; align-items: center; gap: 8px;
      padding: 10px 16px; border-top: 1px solid rgba(128,128,128,0.15);
    }
    #dictation-actions button {
      background: none; border: 1px solid rgba(128,128,128,0.3); border-radius: 8px;
      padding: 6px 16px; cursor: pointer; color: inherit; font-size: 13px;
      font-weight: 500; transition: all 0.15s;
    }
    #dictation-actions button:hover { border-color: rgba(128,128,128,0.6); }
    #dictation-actions button.send-btn {
      background: rgba(80,200,120,0.15); border-color: rgba(80,200,120,0.5);
    }
    #dictation-actions button.send-btn:hover {
      background: rgba(80,200,120,0.25); border-color: rgba(80,200,120,0.8);
    }
    #dictation-actions .hint {
      margin-left: auto; font-size: 11px; opacity: 0.4;
    }
  </style>
</head>
<body>
  <div id="status">Loading...</div>
  <div id="toolbar-tab" title="Toggle toolbar">
    <span class="arrow">&#x25C0;</span>
  </div>
  <div id="toolbar-wrapper">
    <div id="toolbar">
      <div class="group-label">Theme</div>
      <select id="theme-select" title="Color theme"></select>
      <button id="theme-toggle" title="Toggle light/dark mode">&#x2600;&#xFE0F;</button>
      <div class="separator"></div>
      <div class="group-label">Font</div>
      <select id="font-family-select" title="Font family"></select>
      <div class="font-size-row">
        <button id="font-decrease" title="Decrease font size (Ctrl+-)">A-</button>
        <span id="font-size-display"></span>
        <button id="font-increase" title="Increase font size (Ctrl+=)">A+</button>
      </div>
      <div class="separator"></div>
      <div class="tool-row">
        <button id="search-btn" title="Search (Ctrl+Shift+F)">&#x1F50D;</button>
        <button id="speak-btn" title="Voice (Option+V)">
          <span class="speak-dot" style="display:none;"></span>
          &#x1F3A4;
        </button>
        <button id="split-btn" title="Split pane (Ctrl+Shift+D)">&#x229E;</button>
        <button id="close-pane-btn" title="Close pane (Ctrl+Shift+W)" style="display:none;">&#x2715;</button>
        <button id="next-pane-btn" title="Next pane (Ctrl+Shift+])" style="display:none;">&#x21C6;</button>
      </div>
    </div>
  </div>

  <!-- Search bar overlay -->
  <div id="search-bar">
    <input id="search-input" type="text" placeholder="Search..." autocomplete="off" spellcheck="false">
    <button id="search-prev" title="Previous (Shift+Enter)">&#x25B2;</button>
    <button id="search-next" title="Next (Enter)">&#x25BC;</button>
    <button id="search-close" title="Close (Escape)">&#x2715;</button>
  </div>

  <!-- Voice dictation preview -->
  <div id="dictation-preview">
    <div id="dictation-header">
      <span class="rec-dot"></span>
      <span>Voice Dictation</span>
      <span class="shortcut">&#x2325;V</span>
    </div>
    <textarea id="dictation-input" placeholder="Start speaking..."></textarea>
    <div id="dictation-interim"></div>
    <div id="dictation-actions">
      <button id="dictation-send" class="send-btn">Send &#x23CE;</button>
      <button id="dictation-cancel">Cancel</button>
      <span class="hint">Enter to send &middot; Esc to cancel</span>
    </div>
  </div>

  <div id="pane-container"></div>

  <script src="/static/lib/xterm.js"></script>
  <script src="/static/lib/addon-fit.js"></script>
  <script src="/static/lib/addon-web-links.js"></script>
  <script src="/static/lib/addon-search.js"></script>
  <script src="/static/lib/addon-image.js"></script>
  <script>
    // ── Theme Presets ──────────────────────────────────────────────
    const themes = {
      'Dark': {
        type: 'dark',
        body: '#1e1e1e',
        theme: {
          background: '#1e1e1e', foreground: '#d4d4d4', cursor: '#d4d4d4',
          selectionBackground: '#264f78',
          black: '#1e1e1e', red: '#f44747', green: '#6a9955', yellow: '#d7ba7d',
          blue: '#569cd6', magenta: '#c586c0', cyan: '#4ec9b0', white: '#d4d4d4'
        }
      },
      'Light': {
        type: 'light',
        body: '#f5f5f5',
        theme: {
          background: '#f5f5f5', foreground: '#383a42', cursor: '#526eff',
          selectionBackground: '#d7d7ff',
          black: '#383a42', red: '#e45649', green: '#50a14f', yellow: '#c18401',
          blue: '#4078f2', magenta: '#a626a4', cyan: '#0184bc', white: '#fafafa'
        }
      },
      'Dracula': {
        type: 'dark',
        body: '#282a36',
        theme: {
          background: '#282a36', foreground: '#f8f8f2', cursor: '#f8f8f2',
          selectionBackground: '#44475a',
          black: '#21222c', red: '#ff5555', green: '#50fa7b', yellow: '#f1fa8c',
          blue: '#bd93f9', magenta: '#ff79c6', cyan: '#8be9fd', white: '#f8f8f2'
        }
      },
      'Solarized Dark': {
        type: 'dark',
        body: '#002b36',
        theme: {
          background: '#002b36', foreground: '#839496', cursor: '#839496',
          selectionBackground: '#073642',
          black: '#073642', red: '#dc322f', green: '#859900', yellow: '#b58900',
          blue: '#268bd2', magenta: '#d33682', cyan: '#2aa198', white: '#eee8d5'
        }
      },
      'Solarized Light': {
        type: 'light',
        body: '#fdf6e3',
        theme: {
          background: '#fdf6e3', foreground: '#657b83', cursor: '#657b83',
          selectionBackground: '#eee8d5',
          black: '#073642', red: '#dc322f', green: '#859900', yellow: '#b58900',
          blue: '#268bd2', magenta: '#d33682', cyan: '#2aa198', white: '#fdf6e3'
        }
      },
      'Nord': {
        type: 'dark',
        body: '#2e3440',
        theme: {
          background: '#2e3440', foreground: '#d8dee9', cursor: '#d8dee9',
          selectionBackground: '#434c5e',
          black: '#3b4252', red: '#bf616a', green: '#a3be8c', yellow: '#ebcb8b',
          blue: '#81a1c1', magenta: '#b48ead', cyan: '#88c0d0', white: '#e5e9f0'
        }
      },
      'Monokai': {
        type: 'dark',
        body: '#272822',
        theme: {
          background: '#272822', foreground: '#f8f8f2', cursor: '#f8f8f0',
          selectionBackground: '#49483e',
          black: '#272822', red: '#f92672', green: '#a6e22e', yellow: '#e6db74',
          blue: '#66d9ef', magenta: '#ae81ff', cyan: '#a1efe4', white: '#f8f8f2'
        }
      },
      'GitHub Dark': {
        type: 'dark',
        body: '#0d1117',
        theme: {
          background: '#0d1117', foreground: '#c9d1d9', cursor: '#c9d1d9',
          selectionBackground: '#1f2937',
          black: '#0d1117', red: '#ff7b72', green: '#7ee787', yellow: '#d29922',
          blue: '#79c0ff', magenta: '#d2a8ff', cyan: '#a5d6ff', white: '#c9d1d9'
        }
      }
    };

    // ── Font Families ──────────────────────────────────────────────
    const fontFamilies = {
      'System Default': 'monospace',
      'JetBrains Mono': '"JetBrains Mono", monospace',
      'Fira Code': '"Fira Code", monospace',
      'Cascadia Code': '"Cascadia Code", monospace',
      'Source Code Pro': '"Source Code Pro", monospace'
    };

    // ── State ──────────────────────────────────────────────────────
    const MIN_FONT_SIZE = 8;
    const MAX_FONT_SIZE = 32;
    const DEFAULT_FONT_SIZE = 14;

    let currentFontSize = parseInt(localStorage.getItem('terminal-font-size')) || DEFAULT_FONT_SIZE;
    let currentFontFamily = localStorage.getItem('terminal-font-family') || 'System Default';
    let currentThemeName = localStorage.getItem('terminal-theme-name') || null;
    let lastDarkTheme = localStorage.getItem('terminal-last-dark') || 'Dark';
    let lastLightTheme = localStorage.getItem('terminal-last-light') || 'Light';

    // ── Pane Object Model ─────────────────────────────────────────
    // Each pane: { id, element, term, fitAddon, searchAddon, sessionId, pollInterval }
    let panes = [];
    let activePaneId = null;
    let paneIdCounter = 0;

    function getActivePane() {
      return panes.find(p => p.id === activePaneId) || panes[0];
    }

    function focusPane(id) {
      activePaneId = id;
      panes.forEach(p => {
        p.element.classList.toggle('active', p.id === id);
        if (p.id === id) p.term.focus();
      });
    }

    // Resolve initial theme
    if (!currentThemeName || !themes[currentThemeName]) {
      const prefersDark = !window.matchMedia('(prefers-color-scheme: light)').matches;
      currentThemeName = prefersDark ? 'Dark' : 'Light';
    }

    // ── Theme Application ──────────────────────────────────────────
    function applyTheme(name) {
      const preset = themes[name];
      if (!preset) return;
      currentThemeName = name;
      document.body.style.background = preset.body;
      document.body.style.color = preset.type === 'dark' ? '#fff' : '#383a42';
      document.getElementById('theme-toggle').textContent = preset.type === 'dark' ? '\u2600\uFE0F' : '\uD83C\uDF19';
      const overlayBg = preset.type === 'dark' ? 'rgba(30,30,30,0.9)' : 'rgba(245,245,245,0.9)';
      document.getElementById('search-bar').style.background = overlayBg;
      document.getElementById('dictation-preview').style.background = overlayBg;
      // Apply to all panes
      panes.forEach(p => { p.term.options.theme = preset.theme; });
      if (preset.type === 'dark') {
        lastDarkTheme = name;
        localStorage.setItem('terminal-last-dark', name);
      } else {
        lastLightTheme = name;
        localStorage.setItem('terminal-last-light', name);
      }
      localStorage.setItem('terminal-theme-name', name);
      document.getElementById('theme-select').value = name;
    }

    // ── Font Size ──────────────────────────────────────────────────
    function updateFontSizeDisplay() {
      document.getElementById('font-size-display').textContent = currentFontSize + 'px';
    }

    function setFontSize(size) {
      currentFontSize = Math.max(MIN_FONT_SIZE, Math.min(MAX_FONT_SIZE, size));
      localStorage.setItem('terminal-font-size', currentFontSize);
      updateFontSizeDisplay();
      panes.forEach(p => { p.term.options.fontSize = currentFontSize; });
      refitAllPanes();
    }

    // ── Font Family ────────────────────────────────────────────────
    function setFontFamily(name) {
      const family = fontFamilies[name];
      if (!family) return;
      currentFontFamily = name;
      localStorage.setItem('terminal-font-family', name);
      panes.forEach(p => { p.term.options.fontFamily = family; });
      refitAllPanes();
      document.getElementById('font-family-select').value = name;
    }

    // ── Refit all panes ─────────────────────────────────────────────
    function refitAllPanes() {
      panes.forEach(p => {
        p.fitAddon.fit();
        if (p.sessionId) sendResize(p.term.cols, p.term.rows, p.sessionId);
      });
    }

    // ── Populate toolbar dropdowns ─────────────────────────────────
    const themeSelect = document.getElementById('theme-select');
    Object.keys(themes).forEach(name => {
      const opt = document.createElement('option');
      opt.value = name; opt.textContent = name;
      themeSelect.appendChild(opt);
    });
    themeSelect.value = currentThemeName;
    themeSelect.addEventListener('change', e => applyTheme(e.target.value));

    const fontFamilySelect = document.getElementById('font-family-select');
    Object.keys(fontFamilies).forEach(name => {
      const opt = document.createElement('option');
      opt.value = name; opt.textContent = name;
      fontFamilySelect.appendChild(opt);
    });
    fontFamilySelect.value = currentFontFamily;
    fontFamilySelect.addEventListener('change', e => setFontFamily(e.target.value));

    document.getElementById('theme-toggle').addEventListener('click', () => {
      const currentType = themes[currentThemeName].type;
      applyTheme(currentType === 'dark' ? lastLightTheme : lastDarkTheme);
    });

    document.getElementById('font-decrease').addEventListener('click', () => setFontSize(currentFontSize - 1));
    document.getElementById('font-increase').addEventListener('click', () => setFontSize(currentFontSize + 1));

    applyTheme(currentThemeName);
    updateFontSizeDisplay();

    // ── Toolbar drawer toggle ──────────────────────────────────────
    const toolbarWrapper = document.getElementById('toolbar-wrapper');
    const toolbarTab = document.getElementById('toolbar-tab');
    const toolbarPanel = document.getElementById('toolbar');
    toolbarTab.addEventListener('click', () => {
      const isOpen = toolbarWrapper.classList.toggle('open');
      if (isOpen) {
        requestAnimationFrame(() => {
          const w = toolbarPanel.offsetWidth;
          toolbarTab.style.right = w + 'px';
        });
      } else {
        toolbarTab.style.right = '0';
      }
    });

    // ── Search ─────────────────────────────────────────────────────
    let searchVisible = false;
    const searchBar = document.getElementById('search-bar');
    const searchInput = document.getElementById('search-input');

    function toggleSearch() {
      searchVisible = !searchVisible;
      searchBar.classList.toggle('visible', searchVisible);
      if (searchVisible) {
        searchInput.focus();
        searchInput.select();
      } else {
        const ap = getActivePane();
        if (ap && ap.searchAddon) ap.searchAddon.clearDecorations();
        if (ap) ap.term.focus();
      }
    }

    function doSearch(direction) {
      const ap = getActivePane();
      if (!ap || !ap.searchAddon) return;
      const query = searchInput.value;
      if (!query) return;
      const opts = { decorations: { matchOverviewRuler: '#888', activeMatchColorOverviewRuler: '#ffb000' } };
      if (direction === 'next') {
        ap.searchAddon.findNext(query, opts);
      } else {
        ap.searchAddon.findPrevious(query, opts);
      }
    }

    searchInput.addEventListener('input', () => doSearch('next'));
    document.getElementById('search-next').addEventListener('click', () => doSearch('next'));
    document.getElementById('search-prev').addEventListener('click', () => doSearch('prev'));
    document.getElementById('search-close').addEventListener('click', () => toggleSearch());
    document.getElementById('search-btn').addEventListener('click', () => toggleSearch());

    searchInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') { e.preventDefault(); doSearch(e.shiftKey ? 'prev' : 'next'); }
      if (e.key === 'Escape') { e.preventDefault(); toggleSearch(); }
    });

    // ── Voice Dictation ────────────────────────────────────────────
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition = null;
    let dictationActive = false;
    const speakBtn = document.getElementById('speak-btn');
    const speakDot = speakBtn.querySelector('.speak-dot');
    const dictationPreview = document.getElementById('dictation-preview');
    const dictationInput = document.getElementById('dictation-input');
    const dictationInterim = document.getElementById('dictation-interim');

    if (SpeechRecognition) {
      speakBtn.classList.add('supported');
      recognition = new SpeechRecognition();
      recognition.continuous = true;
      recognition.interimResults = true;
      recognition.lang = 'en-US';

      recognition.onresult = (event) => {
        let final = '';
        let interim = '';
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const transcript = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            final += transcript;
          } else {
            interim += transcript;
          }
        }
        if (final) {
          dictationInput.value = (dictationInput.value + (dictationInput.value ? ' ' : '') + final).trim();
          dictationInterim.textContent = '';
          dictationInterim.classList.remove('has-text');
        }
        if (interim) {
          dictationInterim.textContent = interim;
          dictationInterim.classList.add('has-text');
        }
      };

      recognition.onerror = () => stopDictation();
      recognition.onend = () => {
        if (dictationActive) {
          try { recognition.start(); } catch(e) { stopDictation(); }
        }
      };
    }

    function startDictation() {
      if (!recognition || dictationActive) return;
      dictationActive = true;
      speakBtn.classList.add('recording');
      speakDot.style.display = '';
      speakBtn.innerHTML = '<span class="speak-dot"></span> &#x1F3A4;';
      dictationPreview.classList.add('visible');
      dictationInput.value = '';
      dictationInterim.textContent = '';
      dictationInterim.classList.remove('has-text');
      dictationInput.focus();
      try { recognition.start(); } catch(e) { stopDictation(); }
    }

    function stopDictation() {
      dictationActive = false;
      speakBtn.classList.remove('recording');
      speakBtn.innerHTML = '&#x1F3A4;';
      if (recognition) { try { recognition.stop(); } catch(e) {} }
    }

    function closeDictation() {
      stopDictation();
      dictationPreview.classList.remove('visible');
      dictationInput.value = '';
      dictationInterim.textContent = '';
      dictationInterim.classList.remove('has-text');
      const ap = getActivePane();
      if (ap) ap.term.focus();
    }

    function sendDictation() {
      const text = dictationInput.value.trim();
      const ap = getActivePane();
      if (text && ap && ap.sessionId) {
        sendInput(text, ap.sessionId);
      }
      closeDictation();
    }

    speakBtn.addEventListener('click', () => {
      if (dictationActive) closeDictation();
      else startDictation();
    });
    document.getElementById('dictation-send').addEventListener('click', sendDictation);
    document.getElementById('dictation-cancel').addEventListener('click', closeDictation);
    dictationInput.addEventListener('keydown', e => {
      if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendDictation(); }
      if (e.key === 'Escape') { e.preventDefault(); closeDictation(); }
    });

    // ── Global Keyboard Shortcuts ──────────────────────────────────
    document.addEventListener('keydown', e => {
      // Ctrl+= : increase font
      if (e.ctrlKey && !e.altKey && !e.shiftKey && (e.key === '=' || e.key === '+')) {
        e.preventDefault(); setFontSize(currentFontSize + 1); return;
      }
      // Ctrl+- : decrease font
      if (e.ctrlKey && !e.altKey && !e.shiftKey && e.key === '-') {
        e.preventDefault(); setFontSize(currentFontSize - 1); return;
      }
      // Ctrl+0 : reset font
      if (e.ctrlKey && !e.altKey && !e.shiftKey && e.key === '0') {
        e.preventDefault(); setFontSize(DEFAULT_FONT_SIZE); return;
      }
      // Ctrl+Shift+F : toggle search
      if (e.ctrlKey && e.shiftKey && e.key === 'F') {
        e.preventDefault(); toggleSearch(); return;
      }
      // Alt+V (Option+V) : toggle voice dictation
      if (e.altKey && !e.ctrlKey && !e.shiftKey && e.code === 'KeyV') {
        e.preventDefault();
        if (dictationActive) closeDictation();
        else startDictation();
        return;
      }
      // Ctrl+Shift+D : split pane
      if (e.ctrlKey && e.shiftKey && e.key === 'D') {
        e.preventDefault(); splitPane(); return;
      }
      // Ctrl+Shift+W : close active pane
      if (e.ctrlKey && e.shiftKey && e.key === 'W') {
        e.preventDefault(); closeActivePane(); return;
      }
      // Ctrl+Shift+] : next pane — use e.code because Shift+] produces '}'
      if (e.ctrlKey && e.shiftKey && e.code === 'BracketRight') {
        e.preventDefault(); cyclePaneFocus('next'); return;
      }
      // Ctrl+Shift+[ : prev pane — use e.code because Shift+[ produces '{'
      if (e.ctrlKey && e.shiftKey && e.code === 'BracketLeft') {
        e.preventDefault(); cyclePaneFocus('prev'); return;
      }
    });

    // ── Session / IO (parameterized by sessionId) ──────────────────
    const status = document.getElementById('status');

    async function createSession() {
      const resp = await fetch('/api/session', { method: 'POST' });
      const data = await resp.json();
      if (data.error) throw new Error(data.error);
      return data.session_id;
    }

    async function sendInput(input, sid) {
      if (!sid) return;
      await fetch('/api/input', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ session_id: sid, input: input })
      });
    }

    async function sendResize(cols, rows, sid) {
      if (!sid) return;
      await fetch('/api/resize', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ session_id: sid, cols: cols, rows: rows })
      });
    }

    async function pollOutput(pane) {
      if (!pane.sessionId) return;
      try {
        const resp = await fetch('/api/output', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ session_id: pane.sessionId })
        });
        if (!resp.ok) {
          pane.term.write('\r\n\x1b[31mSession ended.\x1b[0m\r\n');
          cleanupPane(pane);
          return;
        }
        const data = await resp.json();
        if (data.output) pane.term.write(data.output);
        if (data.exited) {
          pane.term.write('\r\n\x1b[33mShell process exited.\x1b[0m\r\n');
          cleanupPane(pane);
        }
      } catch (e) {
        console.error('Poll error:', e);
      }
    }

    function cleanupPane(pane) {
      if (pane.pollInterval) { clearInterval(pane.pollInterval); pane.pollInterval = null; }
      if (pane.sessionId) {
        navigator.sendBeacon('/api/session/close', JSON.stringify({ session_id: pane.sessionId }));
        pane.sessionId = null;
      }
    }

    function cleanupAllPanes() {
      panes.forEach(p => cleanupPane(p));
    }

    // ── Pane Management ────────────────────────────────────────────
    async function createPane() {
      const id = 'pane-' + (++paneIdCounter);
      const container = document.getElementById('pane-container');
      const element = document.createElement('div');
      element.className = 'pane';
      element.id = id;

      // Add divider before second pane
      if (panes.length === 1) {
        const divider = document.createElement('div');
        divider.id = 'pane-divider';
        container.appendChild(divider);
        setupDividerDrag(divider);
      }

      container.appendChild(element);

      const term = new Terminal({
        cursorBlink: true,
        fontSize: currentFontSize,
        fontFamily: fontFamilies[currentFontFamily] || 'monospace',
        theme: themes[currentThemeName].theme
      });

      const fitAddon = new FitAddon.FitAddon();
      term.loadAddon(fitAddon);
      term.loadAddon(new WebLinksAddon.WebLinksAddon());

      let searchAddon = null;
      if (typeof SearchAddon !== 'undefined') {
        searchAddon = new SearchAddon.SearchAddon();
        term.loadAddon(searchAddon);
      }

      if (typeof ImageAddon !== 'undefined' && ImageAddon.ImageAddon) {
        term.loadAddon(new ImageAddon.ImageAddon({
          sixelSupport: true,
          sixelScrolling: true,
          iipSupport: true,
          enableSizeReports: true,
          storageLimit: 128
        }));
      }

      term.open(element);
      fitAddon.fit();

      const sid = await createSession();
      await sendResize(term.cols, term.rows, sid);

      term.write('\x1b[32mConnected. Type "claude" to start coding.\x1b[0m\r\n');
      term.write('\x1b[90mProjects in ~/projects auto-sync to Workspace on git commit.\x1b[0m\r\n');
      term.write('\x1b[90mCtrl+Shift+D split pane \u2502 Ctrl+Shift+W close pane \u2502 Ctrl+Shift+] switch pane\x1b[0m\r\n\r\n');

      const pane = { id, element, term, fitAddon, searchAddon, sessionId: sid, pollInterval: null };
      term.onData(data => sendInput(data, pane.sessionId));
      pane.pollInterval = setInterval(() => pollOutput(pane), 100);

      // Click to focus
      element.addEventListener('mousedown', () => focusPane(id));

      panes.push(pane);
      focusPane(id);

      return pane;
    }

    async function splitPane() {
      if (panes.length >= 2) return;
      status.textContent = 'Splitting...';
      status.style.display = '';
      try {
        await createPane();
        // Reset flex for even split
        panes.forEach(p => { p.element.style.flex = '1'; });
        refitAllPanes();
        updatePaneButtons();
        status.style.display = 'none';
      } catch (e) {
        status.textContent = 'Split failed: ' + e.message;
        status.style.color = '#ff5555';
      }
    }

    function closeActivePane() {
      if (panes.length <= 1) return;
      const ap = getActivePane();
      if (!ap) return;

      cleanupPane(ap);
      ap.term.dispose();
      ap.element.remove();

      // Remove divider
      const divider = document.getElementById('pane-divider');
      if (divider) divider.remove();

      panes = panes.filter(p => p.id !== ap.id);

      // Reset remaining pane to full width
      if (panes.length === 1) {
        panes[0].element.style.flex = '1';
      }

      focusPane(panes[0].id);
      refitAllPanes();
      updatePaneButtons();
    }

    function cyclePaneFocus(direction) {
      if (panes.length <= 1) return;
      const idx = panes.findIndex(p => p.id === activePaneId);
      const next = direction === 'next'
        ? (idx + 1) % panes.length
        : (idx - 1 + panes.length) % panes.length;
      focusPane(panes[next].id);
    }

    // ── Divider Drag ───────────────────────────────────────────────
    function setupDividerDrag(divider) {
      let dragging = false;

      divider.addEventListener('mousedown', e => {
        e.preventDefault();
        dragging = true;
        divider.classList.add('dragging');
        document.body.style.cursor = 'col-resize';
        document.body.style.userSelect = 'none';
      });

      document.addEventListener('mousemove', e => {
        if (!dragging || panes.length < 2) return;
        const container = document.getElementById('pane-container');
        const rect = container.getBoundingClientRect();
        let pct = ((e.clientX - rect.left) / rect.width) * 100;
        pct = Math.max(15, Math.min(85, pct));
        panes[0].element.style.flex = `0 0 ${pct}%`;
        panes[1].element.style.flex = '1 1 0';
        refitAllPanes();
      });

      document.addEventListener('mouseup', () => {
        if (dragging) {
          dragging = false;
          divider.classList.remove('dragging');
          document.body.style.cursor = '';
          document.body.style.userSelect = '';
          refitAllPanes();
        }
      });
    }

    // ── Pane toolbar buttons ────────────────────────────────────────
    document.getElementById('split-btn').addEventListener('click', () => splitPane());
    document.getElementById('close-pane-btn').addEventListener('click', () => closeActivePane());
    document.getElementById('next-pane-btn').addEventListener('click', () => cyclePaneFocus('next'));

    function updatePaneButtons() {
      const multi = panes.length > 1;
      document.getElementById('close-pane-btn').style.display = multi ? '' : 'none';
      document.getElementById('next-pane-btn').style.display = multi ? '' : 'none';
      document.getElementById('split-btn').style.display = panes.length >= 2 ? 'none' : '';
    }

    // ── Toast Notification ──────────────────────────────────────────
    function showToast(message, type = 'info') {
      const toast = document.createElement('div');
      toast.textContent = message;
      toast.style.cssText = `
        position: fixed; bottom: 20px; right: 20px; padding: 10px 18px;
        background: ${type === 'error' ? '#e74c3c' : '#2ecc71'}; color: white;
        border-radius: 6px; font-size: 13px; z-index: 10000;
        opacity: 0; transition: opacity 0.3s;
      `;
      document.body.appendChild(toast);
      requestAnimationFrame(() => toast.style.opacity = '1');
      setTimeout(() => {
        toast.style.opacity = '0';
        setTimeout(() => toast.remove(), 300);
      }, 3000);
    }

    // ── Clipboard Paste (image upload) ─────────────────────────────
    // Use capture phase (3rd arg = true) so we fire BEFORE xterm.js consumes the event
    document.addEventListener('paste', async (e) => {
      const active = getActivePane();
      if (!active || !active.sessionId) {
        console.log('[paste] No active pane or session');
        return;
      }

      const items = e.clipboardData?.items;
      if (!items) {
        console.log('[paste] No clipboardData items');
        return;
      }

      console.log('[paste] Items:', Array.from(items).map(i => i.type));

      for (const item of items) {
        if (item.type.startsWith('image/')) {
          e.preventDefault();
          const blob = item.getAsFile();
          if (!blob) { console.log('[paste] Could not get file from item'); continue; }

          console.log('[paste] Uploading image:', blob.type, blob.size, 'bytes');
          const ext = item.type.split('/')[1] || 'png';
          const formData = new FormData();
          formData.append('file', blob, `clipboard-${Date.now()}.${ext}`);

          try {
            const resp = await fetch('/api/upload', { method: 'POST', body: formData });
            console.log('[paste] Response status:', resp.status);
            if (!resp.ok) {
              const text = await resp.text();
              console.error('[paste] Upload failed:', resp.status, text);
              showToast(`Upload failed (${resp.status})`, 'error');
              return;
            }
            const data = await resp.json();
            if (data.path) {
              sendInput(data.path + ' ', active.sessionId);
              showToast('Image saved: ' + data.path);
            } else if (data.error) {
              showToast('Upload error: ' + data.error, 'error');
            }
          } catch (err) {
            console.error('[paste] Upload exception:', err);
            showToast('Upload failed: ' + err.message, 'error');
          }
          return;
        }
      }
      // Text paste — xterm handles natively
    }, true);  // capture phase

    // ── Drag-and-Drop (image upload fallback) ──────────────────────
    document.addEventListener('dragover', (e) => e.preventDefault());
    document.addEventListener('drop', async (e) => {
      e.preventDefault();
      const active = getActivePane();
      if (!active || !active.sessionId) return;

      for (const file of e.dataTransfer.files) {
        if (!file.type.startsWith('image/')) continue;

        const formData = new FormData();
        formData.append('file', file, file.name);

        try {
          const resp = await fetch('/api/upload', { method: 'POST', body: formData });
          console.log('[drop] Response status:', resp.status);
          if (!resp.ok) {
            const text = await resp.text();
            console.error('[drop] Upload failed:', resp.status, text);
            showToast(`Upload failed (${resp.status})`, 'error');
            continue;
          }
          const data = await resp.json();
          if (data.path) {
            sendInput(data.path + ' ', active.sessionId);
            showToast('Image saved: ' + data.path);
          } else if (data.error) {
            showToast('Upload error: ' + data.error, 'error');
          }
        } catch (err) {
          console.error('[drop] Upload exception:', err);
          showToast('Upload failed: ' + err.message, 'error');
        }
      }
    });

    // ── Init ───────────────────────────────────────────────────────
    async function init() {
      try {
        status.textContent = 'Initializing terminal...';

        if (typeof Terminal === 'undefined') throw new Error('xterm.js not loaded');
        if (typeof FitAddon === 'undefined') throw new Error('FitAddon not loaded');

        await createPane();

        status.textContent = 'Connected!';
        setTimeout(() => { status.style.display = 'none'; }, 1000);

        window.addEventListener('resize', () => refitAllPanes());
        window.addEventListener('beforeunload', () => cleanupAllPanes());

      } catch (e) {
        status.textContent = 'Error: ' + e.message;
        status.style.color = '#ff5555';
        console.error(e);
      }
    }

    init();
  </script>
</body>
</html>
