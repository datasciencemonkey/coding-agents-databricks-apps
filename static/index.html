<!DOCTYPE html>
<html>
<head>
  <title>Terminal</title>
  <link rel="stylesheet" href="/static/lib/xterm.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cascadia+Code&family=Fira+Code&family=JetBrains+Mono&family=Source+Code+Pro&display=swap" rel="stylesheet">
  <style>
    body { margin: 0; font-family: monospace; transition: background 0.3s, color 0.3s; }
    #terminal { height: 100vh; width: 100vw; }
    #status { position: absolute; top: 10px; left: 10px; z-index: 1000; }

    /* Toolbar — right-edge slide-out drawer, anchored bottom-right */
    #toolbar-tab {
      position: fixed; bottom: 10px; right: 0; z-index: 1001;
      cursor: pointer; padding: 8px 3px;
      background: rgba(0,0,0,0.25); border-radius: 6px 0 0 6px;
      border: 1px solid rgba(128,128,128,0.25); border-right: none;
      backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
      color: inherit; font-size: 14px; line-height: 1;
      display: flex; align-items: center; justify-content: center;
      writing-mode: vertical-rl; letter-spacing: 2px;
      transition: background 0.2s, right 0.25s ease;
      user-select: none;
    }
    #toolbar-tab:hover { background: rgba(0,0,0,0.4); }
    #toolbar-tab .arrow { font-size: 10px; transition: transform 0.3s; display: block; margin-bottom: 4px; }
    #toolbar-wrapper.open #toolbar-tab .arrow { transform: rotate(180deg); }
    #toolbar-wrapper { position: fixed; bottom: 0; right: 0; z-index: 1000; pointer-events: none; }
    #toolbar {
      pointer-events: auto;
      display: flex; flex-direction: column; gap: 10px;
      padding: 12px 10px; min-width: 160px;
      background: rgba(0,0,0,0.2);
      border-left: 1px solid rgba(128,128,128,0.2);
      border-top: 1px solid rgba(128,128,128,0.2);
      border-top-left-radius: 10px;
      backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
      max-height: 80vh; box-sizing: border-box; overflow-y: auto;
      transform: translateX(100%); transition: transform 0.25s ease;
    }
    #toolbar-wrapper.open #toolbar { transform: translateX(0); }
    #toolbar .group-label {
      font-size: 10px; text-transform: uppercase; letter-spacing: 1px;
      opacity: 0.45; padding: 0 2px; margin-top: 2px;
    }
    #toolbar select, #toolbar button {
      background: none; border: 1px solid rgba(128,128,128,0.4); border-radius: 4px;
      padding: 4px 8px; cursor: pointer; font-size: 12px; line-height: 1.4;
      color: inherit; transition: border-color 0.2s; width: 100%;
      text-align: left; box-sizing: border-box;
    }
    #toolbar select:hover, #toolbar button:hover { border-color: rgba(128,128,128,0.8); }
    #toolbar select { font-family: inherit; }
    #toolbar button.icon-btn { font-size: 14px; display: flex; align-items: center; gap: 6px; }
    #toolbar .font-size-row {
      display: flex; align-items: center; gap: 4px;
    }
    #toolbar .font-size-row button { width: auto; flex-shrink: 0; padding: 4px 8px; text-align: center; }
    #toolbar .font-size-row span { flex: 1; text-align: center; font-size: 12px; }
    #toolbar .separator { height: 1px; width: 100%; background: rgba(128,128,128,0.2); }

    /* Speak button inside toolbar */
    #speak-btn {
      display: none;
    }
    #speak-btn.supported { display: flex; align-items: center; gap: 6px; }
    #speak-btn.recording { border-color: rgba(255,80,80,0.5); }
    #speak-btn.recording .speak-dot {
      width: 8px; height: 8px; border-radius: 50%; background: #ff4444;
      animation: pulse 1s infinite; flex-shrink: 0;
    }

    /* Search bar */
    #search-bar {
      display: none; position: fixed; top: 10px; right: 40px; z-index: 1001;
      padding: 6px 8px; border-radius: 6px;
      border: 1px solid rgba(128,128,128,0.4);
      backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
      gap: 4px; align-items: center;
    }
    #search-bar.visible { display: flex; }
    #search-bar input {
      background: transparent; border: 1px solid rgba(128,128,128,0.3); border-radius: 3px;
      padding: 3px 6px; font-size: 13px; color: inherit; outline: none; width: 200px;
      font-family: inherit;
    }
    #search-bar input:focus { border-color: rgba(100,150,255,0.6); }
    #search-bar button {
      background: none; border: 1px solid rgba(128,128,128,0.3); border-radius: 3px;
      padding: 2px 8px; cursor: pointer; color: inherit; font-size: 12px;
    }
    #search-bar button:hover { border-color: rgba(128,128,128,0.7); }

    /* Voice dictation */
    @keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.5; } }
    #dictation-preview {
      display: none; position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
      z-index: 1001; width: min(85vw, 700px); border-radius: 16px;
      border: 1px solid rgba(128,128,128,0.25);
      backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
      box-shadow: 0 8px 32px rgba(0,0,0,0.3), 0 0 0 1px rgba(255,255,255,0.05) inset;
      flex-direction: column; overflow: hidden;
    }
    #dictation-preview.visible { display: flex; }
    #dictation-header {
      display: flex; align-items: center; gap: 8px;
      padding: 12px 16px; border-bottom: 1px solid rgba(128,128,128,0.15);
      font-size: 13px; font-weight: 600; letter-spacing: 0.3px;
    }
    #dictation-header .rec-dot {
      width: 8px; height: 8px; border-radius: 50%; background: #ff4444;
      animation: pulse 1s infinite; flex-shrink: 0;
    }
    #dictation-header .shortcut {
      margin-left: auto; font-size: 11px; opacity: 0.5; font-weight: 400;
    }
    #dictation-input {
      width: 100%; min-height: 80px; max-height: 200px; resize: vertical;
      background: transparent; border: none; padding: 14px 16px;
      font-size: 16px; line-height: 1.5; color: inherit;
      outline: none; font-family: inherit; word-wrap: break-word;
      box-sizing: border-box;
    }
    #dictation-input::placeholder { opacity: 0.4; }
    #dictation-interim {
      padding: 0 16px 8px; font-size: 14px; line-height: 1.4;
      font-style: italic; opacity: 0.45; min-height: 0;
      word-wrap: break-word; display: none;
    }
    #dictation-interim.has-text { display: block; }
    #dictation-actions {
      display: flex; align-items: center; gap: 8px;
      padding: 10px 16px; border-top: 1px solid rgba(128,128,128,0.15);
    }
    #dictation-actions button {
      background: none; border: 1px solid rgba(128,128,128,0.3); border-radius: 8px;
      padding: 6px 16px; cursor: pointer; color: inherit; font-size: 13px;
      font-weight: 500; transition: all 0.15s;
    }
    #dictation-actions button:hover { border-color: rgba(128,128,128,0.6); }
    #dictation-actions button.send-btn {
      background: rgba(80,200,120,0.15); border-color: rgba(80,200,120,0.5);
    }
    #dictation-actions button.send-btn:hover {
      background: rgba(80,200,120,0.25); border-color: rgba(80,200,120,0.8);
    }
    #dictation-actions .hint {
      margin-left: auto; font-size: 11px; opacity: 0.4;
    }
  </style>
</head>
<body>
  <div id="status">Loading...</div>
  <div id="toolbar-tab" title="Toggle toolbar">
    <span class="arrow">&#x25C0;</span>
  </div>
  <div id="toolbar-wrapper">
    <div id="toolbar">
      <div class="group-label">Theme</div>
      <select id="theme-select" title="Color theme"></select>
      <button id="theme-toggle" class="icon-btn" title="Toggle light/dark mode">&#x2600;&#xFE0F; Toggle</button>
      <div class="separator"></div>
      <div class="group-label">Font</div>
      <select id="font-family-select" title="Font family"></select>
      <div class="font-size-row">
        <button id="font-decrease" title="Decrease font size (Ctrl+-)">A-</button>
        <span id="font-size-display"></span>
        <button id="font-increase" title="Increase font size (Ctrl+=)">A+</button>
      </div>
      <div class="separator"></div>
      <div class="group-label">Tools</div>
      <button id="search-btn" class="icon-btn" title="Search (Ctrl+Shift+F)">&#x1F50D; Search</button>
      <button id="speak-btn" class="icon-btn" title="Voice dictation (Option+V)">
        <span class="speak-dot" style="display:none;"></span>
        &#x1F3A4; Speak
      </button>
    </div>
  </div>

  <!-- Search bar overlay -->
  <div id="search-bar">
    <input id="search-input" type="text" placeholder="Search..." autocomplete="off" spellcheck="false">
    <button id="search-prev" title="Previous (Shift+Enter)">&#x25B2;</button>
    <button id="search-next" title="Next (Enter)">&#x25BC;</button>
    <button id="search-close" title="Close (Escape)">&#x2715;</button>
  </div>

  <!-- Voice dictation preview -->
  <div id="dictation-preview">
    <div id="dictation-header">
      <span class="rec-dot"></span>
      <span>Voice Dictation</span>
      <span class="shortcut">&#x2325;V</span>
    </div>
    <textarea id="dictation-input" placeholder="Start speaking..."></textarea>
    <div id="dictation-interim"></div>
    <div id="dictation-actions">
      <button id="dictation-send" class="send-btn">Send &#x23CE;</button>
      <button id="dictation-cancel">Cancel</button>
      <span class="hint">Enter to send &middot; Esc to cancel</span>
    </div>
  </div>

  <div id="terminal"></div>

  <script src="/static/lib/xterm.js"></script>
  <script src="/static/lib/addon-fit.js"></script>
  <script src="/static/lib/addon-web-links.js"></script>
  <script src="/static/lib/addon-search.js"></script>
  <script>
    // ── Theme Presets ──────────────────────────────────────────────
    const themes = {
      'Dark': {
        type: 'dark',
        body: '#1e1e1e',
        theme: {
          background: '#1e1e1e', foreground: '#d4d4d4', cursor: '#d4d4d4',
          selectionBackground: '#264f78',
          black: '#1e1e1e', red: '#f44747', green: '#6a9955', yellow: '#d7ba7d',
          blue: '#569cd6', magenta: '#c586c0', cyan: '#4ec9b0', white: '#d4d4d4'
        }
      },
      'Light': {
        type: 'light',
        body: '#f5f5f5',
        theme: {
          background: '#f5f5f5', foreground: '#383a42', cursor: '#526eff',
          selectionBackground: '#d7d7ff',
          black: '#383a42', red: '#e45649', green: '#50a14f', yellow: '#c18401',
          blue: '#4078f2', magenta: '#a626a4', cyan: '#0184bc', white: '#fafafa'
        }
      },
      'Dracula': {
        type: 'dark',
        body: '#282a36',
        theme: {
          background: '#282a36', foreground: '#f8f8f2', cursor: '#f8f8f2',
          selectionBackground: '#44475a',
          black: '#21222c', red: '#ff5555', green: '#50fa7b', yellow: '#f1fa8c',
          blue: '#bd93f9', magenta: '#ff79c6', cyan: '#8be9fd', white: '#f8f8f2'
        }
      },
      'Solarized Dark': {
        type: 'dark',
        body: '#002b36',
        theme: {
          background: '#002b36', foreground: '#839496', cursor: '#839496',
          selectionBackground: '#073642',
          black: '#073642', red: '#dc322f', green: '#859900', yellow: '#b58900',
          blue: '#268bd2', magenta: '#d33682', cyan: '#2aa198', white: '#eee8d5'
        }
      },
      'Solarized Light': {
        type: 'light',
        body: '#fdf6e3',
        theme: {
          background: '#fdf6e3', foreground: '#657b83', cursor: '#657b83',
          selectionBackground: '#eee8d5',
          black: '#073642', red: '#dc322f', green: '#859900', yellow: '#b58900',
          blue: '#268bd2', magenta: '#d33682', cyan: '#2aa198', white: '#fdf6e3'
        }
      },
      'Nord': {
        type: 'dark',
        body: '#2e3440',
        theme: {
          background: '#2e3440', foreground: '#d8dee9', cursor: '#d8dee9',
          selectionBackground: '#434c5e',
          black: '#3b4252', red: '#bf616a', green: '#a3be8c', yellow: '#ebcb8b',
          blue: '#81a1c1', magenta: '#b48ead', cyan: '#88c0d0', white: '#e5e9f0'
        }
      },
      'Monokai': {
        type: 'dark',
        body: '#272822',
        theme: {
          background: '#272822', foreground: '#f8f8f2', cursor: '#f8f8f0',
          selectionBackground: '#49483e',
          black: '#272822', red: '#f92672', green: '#a6e22e', yellow: '#e6db74',
          blue: '#66d9ef', magenta: '#ae81ff', cyan: '#a1efe4', white: '#f8f8f2'
        }
      },
      'GitHub Dark': {
        type: 'dark',
        body: '#0d1117',
        theme: {
          background: '#0d1117', foreground: '#c9d1d9', cursor: '#c9d1d9',
          selectionBackground: '#1f2937',
          black: '#0d1117', red: '#ff7b72', green: '#7ee787', yellow: '#d29922',
          blue: '#79c0ff', magenta: '#d2a8ff', cyan: '#a5d6ff', white: '#c9d1d9'
        }
      }
    };

    // ── Font Families ──────────────────────────────────────────────
    const fontFamilies = {
      'System Default': 'monospace',
      'JetBrains Mono': '"JetBrains Mono", monospace',
      'Fira Code': '"Fira Code", monospace',
      'Cascadia Code': '"Cascadia Code", monospace',
      'Source Code Pro': '"Source Code Pro", monospace'
    };

    // ── State ──────────────────────────────────────────────────────
    const MIN_FONT_SIZE = 8;
    const MAX_FONT_SIZE = 32;
    const DEFAULT_FONT_SIZE = 14;

    let currentFontSize = parseInt(localStorage.getItem('terminal-font-size')) || DEFAULT_FONT_SIZE;
    let currentFontFamily = localStorage.getItem('terminal-font-family') || 'System Default';
    let currentThemeName = localStorage.getItem('terminal-theme-name') || null;
    let lastDarkTheme = localStorage.getItem('terminal-last-dark') || 'Dark';
    let lastLightTheme = localStorage.getItem('terminal-last-light') || 'Light';
    let termInstance = null;
    let fitAddonInstance = null;
    let searchAddonInstance = null;

    // Resolve initial theme
    if (!currentThemeName || !themes[currentThemeName]) {
      const prefersDark = !window.matchMedia('(prefers-color-scheme: light)').matches;
      currentThemeName = prefersDark ? 'Dark' : 'Light';
    }

    // ── Theme Application ──────────────────────────────────────────
    function applyTheme(name) {
      const preset = themes[name];
      if (!preset) return;
      currentThemeName = name;
      document.body.style.background = preset.body;
      document.body.style.color = preset.type === 'dark' ? '#fff' : '#383a42';
      document.getElementById('theme-toggle').textContent = preset.type === 'dark' ? '\u2600\uFE0F Light' : '\uD83C\uDF19 Dark';
      // Update overlay backgrounds for theme
      const overlayBg = preset.type === 'dark' ? 'rgba(30,30,30,0.9)' : 'rgba(245,245,245,0.9)';
      document.getElementById('search-bar').style.background = overlayBg;
      document.getElementById('dictation-preview').style.background = overlayBg;
      if (termInstance) {
        termInstance.options.theme = preset.theme;
      }
      if (preset.type === 'dark') {
        lastDarkTheme = name;
        localStorage.setItem('terminal-last-dark', name);
      } else {
        lastLightTheme = name;
        localStorage.setItem('terminal-last-light', name);
      }
      localStorage.setItem('terminal-theme-name', name);
      document.getElementById('theme-select').value = name;
    }

    // ── Font Size ──────────────────────────────────────────────────
    function updateFontSizeDisplay() {
      document.getElementById('font-size-display').textContent = currentFontSize + 'px';
    }

    function setFontSize(size) {
      currentFontSize = Math.max(MIN_FONT_SIZE, Math.min(MAX_FONT_SIZE, size));
      localStorage.setItem('terminal-font-size', currentFontSize);
      updateFontSizeDisplay();
      if (termInstance) {
        termInstance.options.fontSize = currentFontSize;
        refitAndResize();
      }
    }

    // ── Font Family ────────────────────────────────────────────────
    function setFontFamily(name) {
      const family = fontFamilies[name];
      if (!family) return;
      currentFontFamily = name;
      localStorage.setItem('terminal-font-family', name);
      if (termInstance) {
        termInstance.options.fontFamily = family;
        refitAndResize();
      }
      document.getElementById('font-family-select').value = name;
    }

    // ── Refit helper ───────────────────────────────────────────────
    function refitAndResize() {
      if (fitAddonInstance && termInstance) {
        fitAddonInstance.fit();
        sendResize(termInstance.cols, termInstance.rows);
      }
    }

    // ── Populate toolbar dropdowns ─────────────────────────────────
    const themeSelect = document.getElementById('theme-select');
    Object.keys(themes).forEach(name => {
      const opt = document.createElement('option');
      opt.value = name; opt.textContent = name;
      themeSelect.appendChild(opt);
    });
    themeSelect.value = currentThemeName;
    themeSelect.addEventListener('change', e => applyTheme(e.target.value));

    const fontFamilySelect = document.getElementById('font-family-select');
    Object.keys(fontFamilies).forEach(name => {
      const opt = document.createElement('option');
      opt.value = name; opt.textContent = name;
      fontFamilySelect.appendChild(opt);
    });
    fontFamilySelect.value = currentFontFamily;
    fontFamilySelect.addEventListener('change', e => setFontFamily(e.target.value));

    document.getElementById('theme-toggle').addEventListener('click', () => {
      const currentType = themes[currentThemeName].type;
      applyTheme(currentType === 'dark' ? lastLightTheme : lastDarkTheme);
    });

    document.getElementById('font-decrease').addEventListener('click', () => setFontSize(currentFontSize - 1));
    document.getElementById('font-increase').addEventListener('click', () => setFontSize(currentFontSize + 1));

    applyTheme(currentThemeName);
    updateFontSizeDisplay();

    // ── Toolbar drawer toggle ──────────────────────────────────────
    const toolbarWrapper = document.getElementById('toolbar-wrapper');
    const toolbarTab = document.getElementById('toolbar-tab');
    const toolbarPanel = document.getElementById('toolbar');
    toolbarTab.addEventListener('click', () => {
      const isOpen = toolbarWrapper.classList.toggle('open');
      if (isOpen) {
        // Wait for transition to get panel width, then offset tab
        requestAnimationFrame(() => {
          const w = toolbarPanel.offsetWidth;
          toolbarTab.style.right = w + 'px';
        });
      } else {
        toolbarTab.style.right = '0';
      }
    });

    // ── Search ─────────────────────────────────────────────────────
    let searchVisible = false;
    const searchBar = document.getElementById('search-bar');
    const searchInput = document.getElementById('search-input');

    function toggleSearch() {
      searchVisible = !searchVisible;
      searchBar.classList.toggle('visible', searchVisible);
      if (searchVisible) {
        searchInput.focus();
        searchInput.select();
      } else {
        if (searchAddonInstance) searchAddonInstance.clearDecorations();
        if (termInstance) termInstance.focus();
      }
    }

    function doSearch(direction) {
      if (!searchAddonInstance) return;
      const query = searchInput.value;
      if (!query) return;
      const opts = { decorations: { matchOverviewRuler: '#888', activeMatchColorOverviewRuler: '#ffb000' } };
      if (direction === 'next') {
        searchAddonInstance.findNext(query, opts);
      } else {
        searchAddonInstance.findPrevious(query, opts);
      }
    }

    searchInput.addEventListener('input', () => doSearch('next'));
    document.getElementById('search-next').addEventListener('click', () => doSearch('next'));
    document.getElementById('search-prev').addEventListener('click', () => doSearch('prev'));
    document.getElementById('search-close').addEventListener('click', () => toggleSearch());
    document.getElementById('search-btn').addEventListener('click', () => toggleSearch());

    searchInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') { e.preventDefault(); doSearch(e.shiftKey ? 'prev' : 'next'); }
      if (e.key === 'Escape') { e.preventDefault(); toggleSearch(); }
    });

    // ── Voice Dictation ────────────────────────────────────────────
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition = null;
    let dictationActive = false;
    const speakBtn = document.getElementById('speak-btn');
    const speakDot = speakBtn.querySelector('.speak-dot');
    const dictationPreview = document.getElementById('dictation-preview');
    const dictationInput = document.getElementById('dictation-input');
    const dictationInterim = document.getElementById('dictation-interim');

    if (SpeechRecognition) {
      speakBtn.classList.add('supported');
      recognition = new SpeechRecognition();
      recognition.continuous = true;
      recognition.interimResults = true;
      recognition.lang = 'en-US';

      recognition.onresult = (event) => {
        let final = '';
        let interim = '';
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const transcript = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            final += transcript;
          } else {
            interim += transcript;
          }
        }
        if (final) {
          dictationInput.value = (dictationInput.value + (dictationInput.value ? ' ' : '') + final).trim();
          dictationInterim.textContent = '';
          dictationInterim.classList.remove('has-text');
        }
        if (interim) {
          dictationInterim.textContent = interim;
          dictationInterim.classList.add('has-text');
        }
      };

      recognition.onerror = () => stopDictation();
      recognition.onend = () => {
        if (dictationActive) {
          try { recognition.start(); } catch(e) { stopDictation(); }
        }
      };
    }

    function startDictation() {
      if (!recognition || dictationActive) return;
      dictationActive = true;
      speakBtn.classList.add('recording');
      speakDot.style.display = '';
      speakBtn.innerHTML = '<span class="speak-dot"></span> Recording...';
      dictationPreview.classList.add('visible');
      dictationInput.value = '';
      dictationInterim.textContent = '';
      dictationInterim.classList.remove('has-text');
      dictationInput.focus();
      try { recognition.start(); } catch(e) { stopDictation(); }
    }

    function stopDictation() {
      dictationActive = false;
      speakBtn.classList.remove('recording');
      speakBtn.innerHTML = '&#x1F3A4; Speak';
      if (recognition) { try { recognition.stop(); } catch(e) {} }
    }

    function closeDictation() {
      stopDictation();
      dictationPreview.classList.remove('visible');
      dictationInput.value = '';
      dictationInterim.textContent = '';
      dictationInterim.classList.remove('has-text');
      if (termInstance) termInstance.focus();
    }

    function sendDictation() {
      const text = dictationInput.value.trim();
      if (text && sessionId) {
        sendInput(text);
      }
      closeDictation();
    }

    speakBtn.addEventListener('click', () => {
      if (dictationActive) closeDictation();
      else startDictation();
    });
    document.getElementById('dictation-send').addEventListener('click', sendDictation);
    document.getElementById('dictation-cancel').addEventListener('click', closeDictation);
    dictationInput.addEventListener('keydown', e => {
      if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendDictation(); }
      if (e.key === 'Escape') { e.preventDefault(); closeDictation(); }
    });

    // ── Global Keyboard Shortcuts ──────────────────────────────────
    document.addEventListener('keydown', e => {
      // Ctrl+= : increase font
      if (e.ctrlKey && !e.altKey && !e.shiftKey && (e.key === '=' || e.key === '+')) {
        e.preventDefault(); setFontSize(currentFontSize + 1); return;
      }
      // Ctrl+- : decrease font
      if (e.ctrlKey && !e.altKey && !e.shiftKey && e.key === '-') {
        e.preventDefault(); setFontSize(currentFontSize - 1); return;
      }
      // Ctrl+0 : reset font
      if (e.ctrlKey && !e.altKey && !e.shiftKey && e.key === '0') {
        e.preventDefault(); setFontSize(DEFAULT_FONT_SIZE); return;
      }
      // Ctrl+Shift+F : toggle search
      if (e.ctrlKey && e.shiftKey && e.key === 'F') {
        e.preventDefault(); toggleSearch(); return;
      }
      // Alt+V (Option+V) : toggle voice dictation — use e.code because macOS Alt+V produces '√'
      if (e.altKey && !e.ctrlKey && !e.shiftKey && e.code === 'KeyV') {
        e.preventDefault();
        if (dictationActive) closeDictation();
        else startDictation();
        return;
      }
    });

    // ── Session / IO ───────────────────────────────────────────────
    const status = document.getElementById('status');
    let sessionId = null;
    let pollInterval = null;

    async function createSession() {
      const resp = await fetch('/api/session', { method: 'POST' });
      const data = await resp.json();
      if (data.error) throw new Error(data.error);
      return data.session_id;
    }

    async function sendInput(input) {
      if (!sessionId) return;
      await fetch('/api/input', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ session_id: sessionId, input: input })
      });
    }

    async function sendResize(cols, rows) {
      if (!sessionId) return;
      await fetch('/api/resize', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ session_id: sessionId, cols: cols, rows: rows })
      });
    }

    async function pollOutput(term) {
      if (!sessionId) return;
      try {
        const resp = await fetch('/api/output', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ session_id: sessionId })
        });
        if (!resp.ok) {
          cleanupSession();
          term.write('\r\n\x1b[31mSession ended.\x1b[0m\r\n');
          return;
        }
        const data = await resp.json();
        if (data.output) term.write(data.output);
        if (data.exited) {
          term.write('\r\n\x1b[33mShell process exited. You can close this tab.\x1b[0m\r\n');
          cleanupSession();
        }
      } catch (e) {
        console.error('Poll error:', e);
      }
    }

    function cleanupSession() {
      if (pollInterval) { clearInterval(pollInterval); pollInterval = null; }
      if (sessionId) {
        navigator.sendBeacon('/api/session/close', JSON.stringify({ session_id: sessionId }));
        sessionId = null;
      }
    }

    // ── Init ───────────────────────────────────────────────────────
    async function init() {
      try {
        status.textContent = 'Initializing terminal...';

        if (typeof Terminal === 'undefined') throw new Error('xterm.js not loaded');
        if (typeof FitAddon === 'undefined') throw new Error('FitAddon not loaded');

        const term = new Terminal({
          cursorBlink: true,
          fontSize: currentFontSize,
          fontFamily: fontFamilies[currentFontFamily] || 'monospace',
          theme: themes[currentThemeName].theme
        });
        termInstance = term;

        const fitAddon = new FitAddon.FitAddon();
        fitAddonInstance = fitAddon;
        const webLinksAddon = new WebLinksAddon.WebLinksAddon();
        term.loadAddon(fitAddon);
        term.loadAddon(webLinksAddon);

        // Load search addon
        if (typeof SearchAddon !== 'undefined') {
          const searchAddon = new SearchAddon.SearchAddon();
          searchAddonInstance = searchAddon;
          term.loadAddon(searchAddon);
        }

        term.open(document.getElementById('terminal'));
        fitAddon.fit();

        status.textContent = 'Creating session...';
        sessionId = await createSession();
        await sendResize(term.cols, term.rows);

        status.textContent = 'Connected!';
        setTimeout(() => { status.style.display = 'none'; }, 1000);

        term.write('\x1b[32mConnected. Type "claude" to start coding.\x1b[0m\r\n');
        term.write('\x1b[90mProjects in ~/projects auto-sync to Workspace on git commit.\x1b[0m\r\n\r\n');

        term.onData(data => sendInput(data));
        pollInterval = setInterval(() => pollOutput(term), 100);

        window.addEventListener('resize', () => refitAndResize());
        window.addEventListener('beforeunload', () => cleanupSession());

      } catch (e) {
        status.textContent = 'Error: ' + e.message;
        status.style.color = '#ff5555';
        console.error(e);
      }
    }

    init();
  </script>
</body>
</html>
