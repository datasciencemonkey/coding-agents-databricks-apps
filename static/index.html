<!DOCTYPE html>
<html>
<head>
  <title>Terminal</title>
  <link rel="stylesheet" href="/static/lib/xterm.css">
  <style>
    body { margin: 0; font-family: monospace; transition: background 0.3s, color 0.3s; }
    body.dark { background: #1e1e1e; color: #fff; }
    body.light { background: #f5f5f5; color: #383a42; }
    #terminal { height: 100vh; width: 100vw; }
    #status { position: absolute; top: 10px; left: 10px; z-index: 1000; }
    #theme-toggle {
      position: fixed; top: 10px; right: 10px; z-index: 1000;
      background: none; border: 1px solid rgba(128,128,128,0.4); border-radius: 6px;
      padding: 4px 8px; cursor: pointer; font-size: 18px; line-height: 1;
      transition: border-color 0.3s;
    }
    #theme-toggle:hover { border-color: rgba(128,128,128,0.8); }
  </style>
</head>
<body>
  <div id="status">Loading...</div>
  <button id="theme-toggle" title="Toggle light/dark mode"></button>
  <div id="terminal"></div>

  <script src="/static/lib/xterm.js"></script>
  <script src="/static/lib/addon-fit.js"></script>
  <script src="/static/lib/addon-web-links.js"></script>
  <script>
    const darkTheme = {
      background: '#1e1e1e', foreground: '#d4d4d4', cursor: '#d4d4d4',
      selectionBackground: '#264f78',
      black: '#1e1e1e', red: '#f44747', green: '#6a9955', yellow: '#d7ba7d',
      blue: '#569cd6', magenta: '#c586c0', cyan: '#4ec9b0', white: '#d4d4d4'
    };
    const lightTheme = {
      background: '#f5f5f5', foreground: '#383a42', cursor: '#526eff',
      selectionBackground: '#d7d7ff',
      black: '#383a42', red: '#e45649', green: '#50a14f', yellow: '#c18401',
      blue: '#4078f2', magenta: '#a626a4', cyan: '#0184bc', white: '#fafafa'
    };

    function getPreferredMode() {
      const saved = localStorage.getItem('terminal-theme');
      if (saved) return saved;
      return window.matchMedia('(prefers-color-scheme: light)').matches ? 'light' : 'dark';
    }

    let currentMode = getPreferredMode();
    let termInstance = null;

    function applyTheme(mode) {
      currentMode = mode;
      document.body.className = mode;
      document.getElementById('theme-toggle').textContent = mode === 'dark' ? '\u2600\uFE0F' : '\uD83C\uDF19';
      if (termInstance) {
        termInstance.options.theme = mode === 'dark' ? darkTheme : lightTheme;
      }
      localStorage.setItem('terminal-theme', mode);
    }

    document.getElementById('theme-toggle').addEventListener('click', () => {
      applyTheme(currentMode === 'dark' ? 'light' : 'dark');
    });

    applyTheme(currentMode);

    const status = document.getElementById('status');
    let sessionId = null;
    let pollInterval = null;

    async function createSession() {
      const resp = await fetch('/api/session', { method: 'POST' });
      const data = await resp.json();
      if (data.error) throw new Error(data.error);
      return data.session_id;
    }

    async function sendInput(input) {
      if (!sessionId) return;
      await fetch('/api/input', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ session_id: sessionId, input: input })
      });
    }

    async function sendResize(cols, rows) {
      if (!sessionId) return;
      await fetch('/api/resize', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ session_id: sessionId, cols: cols, rows: rows })
      });
    }

    async function pollOutput(term) {
      if (!sessionId) return;
      try {
        const resp = await fetch('/api/output', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ session_id: sessionId })
        });
        if (!resp.ok) {
          // Session gone on server side — stop polling
          cleanupSession();
          term.write('\r\n\x1b[31mSession ended.\x1b[0m\r\n');
          return;
        }
        const data = await resp.json();
        if (data.output) {
          term.write(data.output);
        }
        if (data.exited) {
          term.write('\r\n\x1b[33mShell process exited. You can close this tab.\x1b[0m\r\n');
          cleanupSession();
        }
      } catch (e) {
        console.error('Poll error:', e);
      }
    }

    function cleanupSession() {
      if (pollInterval) {
        clearInterval(pollInterval);
        pollInterval = null;
      }
      if (sessionId) {
        navigator.sendBeacon('/api/session/close', JSON.stringify({ session_id: sessionId }));
        sessionId = null;
      }
    }

    async function init() {
      try {
        status.textContent = 'Initializing terminal...';

        if (typeof Terminal === 'undefined') {
          throw new Error('xterm.js not loaded');
        }
        if (typeof FitAddon === 'undefined') {
          throw new Error('FitAddon not loaded');
        }

        // Initialize terminal
        const term = new Terminal({
          cursorBlink: true,
          theme: currentMode === 'dark' ? darkTheme : lightTheme
        });
        termInstance = term;
        const fitAddon = new FitAddon.FitAddon();
        const webLinksAddon = new WebLinksAddon.WebLinksAddon();
        term.loadAddon(fitAddon);
        term.loadAddon(webLinksAddon);
        term.open(document.getElementById('terminal'));
        fitAddon.fit();

        status.textContent = 'Creating session...';

        // Create session
        sessionId = await createSession();

        // Send initial terminal size to PTY
        await sendResize(term.cols, term.rows);

        status.textContent = 'Connected!';
        setTimeout(() => { status.style.display = 'none'; }, 1000);

        term.write('\x1b[32mConnected. Type "claude" to start coding.\x1b[0m\r\n');
        term.write('\x1b[90mProjects in ~/projects auto-sync to Workspace on git commit.\x1b[0m\r\n\r\n');

        // User types → send to backend
        term.onData(data => sendInput(data));

        // Poll for output every 100ms
        pollInterval = setInterval(() => pollOutput(term), 100);

        // Handle resize - update both xterm and PTY
        window.addEventListener('resize', () => {
          fitAddon.fit();
          sendResize(term.cols, term.rows);
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => cleanupSession());

      } catch (e) {
        status.textContent = 'Error: ' + e.message;
        status.style.color = '#ff5555';
        console.error(e);
      }
    }

    init();
  </script>
</body>
</html>
